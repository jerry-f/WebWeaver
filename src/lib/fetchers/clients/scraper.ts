// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v3.12.4
// source: scraper.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "scraper";

/**
 * TIPS: 只需要维护者一套类型系统，即可保证go和ts 共用， 修改之后，最终要执行命令 `npm run proto:gen` 生成新的
 * 生成新的 go-scraper-service/api/proto/gen/scraper.pb.go 文件和 src/lib/fetchers/clients/scraper.ts 文件
 */
export interface Empty {
}

export interface FetchRequest {
  url: string;
  options: FetchOptions | undefined;
}

export interface FetchOptions {
  timeoutMs: number;
  extractFulltext: boolean;
  processImages: boolean;
  imageProxyBase: string;
  headers: { [key: string]: string };
  /** cycletls, standard, auto */
  strategy: string;
  referer: string;
}

export interface FetchOptions_HeadersEntry {
  key: string;
  value: string;
}

export interface FetchResponse {
  url: string;
  finalUrl: string;
  title: string;
  content: string;
  textContent: string;
  excerpt: string;
  byline: string;
  siteName: string;
  images: Image[];
  readingTime: number;
  strategy: string;
  durationMs: number;
  error: string;
}

export interface Image {
  originalUrl: string;
  proxyUrl: string;
  alt: string;
  isLazy: boolean;
}

export interface HealthResponse {
  status: string;
  maxConcurrent: number;
  available: number;
  cycletlsEnabled: boolean;
}

/** 原始抓取响应（不经过 Readability 处理） */
export interface FetchRawResponse {
  url: string;
  finalUrl: string;
  body: string;
  contentType: string;
  statusCode: number;
  strategy: string;
  durationMs: number;
  error: string;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Empty>): Empty {
    return Empty.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Empty>): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseFetchRequest(): FetchRequest {
  return { url: "", options: undefined };
}

export const FetchRequest: MessageFns<FetchRequest> = {
  encode(message: FetchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.options !== undefined) {
      FetchOptions.encode(message.options, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.options = FetchOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchRequest {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      options: isSet(object.options) ? FetchOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: FetchRequest): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.options !== undefined) {
      obj.options = FetchOptions.toJSON(message.options);
    }
    return obj;
  },

  create(base?: DeepPartial<FetchRequest>): FetchRequest {
    return FetchRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchRequest>): FetchRequest {
    const message = createBaseFetchRequest();
    message.url = object.url ?? "";
    message.options = (object.options !== undefined && object.options !== null)
      ? FetchOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseFetchOptions(): FetchOptions {
  return {
    timeoutMs: 0,
    extractFulltext: false,
    processImages: false,
    imageProxyBase: "",
    headers: {},
    strategy: "",
    referer: "",
  };
}

export const FetchOptions: MessageFns<FetchOptions> = {
  encode(message: FetchOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeoutMs !== 0) {
      writer.uint32(8).int32(message.timeoutMs);
    }
    if (message.extractFulltext !== false) {
      writer.uint32(16).bool(message.extractFulltext);
    }
    if (message.processImages !== false) {
      writer.uint32(24).bool(message.processImages);
    }
    if (message.imageProxyBase !== "") {
      writer.uint32(34).string(message.imageProxyBase);
    }
    globalThis.Object.entries(message.headers).forEach(([key, value]: [string, string]) => {
      FetchOptions_HeadersEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.strategy !== "") {
      writer.uint32(50).string(message.strategy);
    }
    if (message.referer !== "") {
      writer.uint32(58).string(message.referer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timeoutMs = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.extractFulltext = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.processImages = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.imageProxyBase = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = FetchOptions_HeadersEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.headers[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.strategy = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.referer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchOptions {
    return {
      timeoutMs: isSet(object.timeoutMs)
        ? globalThis.Number(object.timeoutMs)
        : isSet(object.timeout_ms)
        ? globalThis.Number(object.timeout_ms)
        : 0,
      extractFulltext: isSet(object.extractFulltext)
        ? globalThis.Boolean(object.extractFulltext)
        : isSet(object.extract_fulltext)
        ? globalThis.Boolean(object.extract_fulltext)
        : false,
      processImages: isSet(object.processImages)
        ? globalThis.Boolean(object.processImages)
        : isSet(object.process_images)
        ? globalThis.Boolean(object.process_images)
        : false,
      imageProxyBase: isSet(object.imageProxyBase)
        ? globalThis.String(object.imageProxyBase)
        : isSet(object.image_proxy_base)
        ? globalThis.String(object.image_proxy_base)
        : "",
      headers: isObject(object.headers)
        ? (globalThis.Object.entries(object.headers) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      strategy: isSet(object.strategy) ? globalThis.String(object.strategy) : "",
      referer: isSet(object.referer) ? globalThis.String(object.referer) : "",
    };
  },

  toJSON(message: FetchOptions): unknown {
    const obj: any = {};
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    if (message.extractFulltext !== false) {
      obj.extractFulltext = message.extractFulltext;
    }
    if (message.processImages !== false) {
      obj.processImages = message.processImages;
    }
    if (message.imageProxyBase !== "") {
      obj.imageProxyBase = message.imageProxyBase;
    }
    if (message.headers) {
      const entries = globalThis.Object.entries(message.headers) as [string, string][];
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.strategy !== "") {
      obj.strategy = message.strategy;
    }
    if (message.referer !== "") {
      obj.referer = message.referer;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchOptions>): FetchOptions {
    return FetchOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchOptions>): FetchOptions {
    const message = createBaseFetchOptions();
    message.timeoutMs = object.timeoutMs ?? 0;
    message.extractFulltext = object.extractFulltext ?? false;
    message.processImages = object.processImages ?? false;
    message.imageProxyBase = object.imageProxyBase ?? "";
    message.headers = (globalThis.Object.entries(object.headers ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.strategy = object.strategy ?? "";
    message.referer = object.referer ?? "";
    return message;
  },
};

function createBaseFetchOptions_HeadersEntry(): FetchOptions_HeadersEntry {
  return { key: "", value: "" };
}

export const FetchOptions_HeadersEntry: MessageFns<FetchOptions_HeadersEntry> = {
  encode(message: FetchOptions_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchOptions_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchOptions_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchOptions_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: FetchOptions_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchOptions_HeadersEntry>): FetchOptions_HeadersEntry {
    return FetchOptions_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchOptions_HeadersEntry>): FetchOptions_HeadersEntry {
    const message = createBaseFetchOptions_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFetchResponse(): FetchResponse {
  return {
    url: "",
    finalUrl: "",
    title: "",
    content: "",
    textContent: "",
    excerpt: "",
    byline: "",
    siteName: "",
    images: [],
    readingTime: 0,
    strategy: "",
    durationMs: 0,
    error: "",
  };
}

export const FetchResponse: MessageFns<FetchResponse> = {
  encode(message: FetchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.finalUrl !== "") {
      writer.uint32(18).string(message.finalUrl);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    if (message.textContent !== "") {
      writer.uint32(42).string(message.textContent);
    }
    if (message.excerpt !== "") {
      writer.uint32(50).string(message.excerpt);
    }
    if (message.byline !== "") {
      writer.uint32(58).string(message.byline);
    }
    if (message.siteName !== "") {
      writer.uint32(66).string(message.siteName);
    }
    for (const v of message.images) {
      Image.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.readingTime !== 0) {
      writer.uint32(80).int32(message.readingTime);
    }
    if (message.strategy !== "") {
      writer.uint32(90).string(message.strategy);
    }
    if (message.durationMs !== 0) {
      writer.uint32(96).int64(message.durationMs);
    }
    if (message.error !== "") {
      writer.uint32(106).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.finalUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.textContent = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.excerpt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.byline = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.siteName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.images.push(Image.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.readingTime = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.strategy = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.durationMs = longToNumber(reader.int64());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchResponse {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      finalUrl: isSet(object.finalUrl)
        ? globalThis.String(object.finalUrl)
        : isSet(object.final_url)
        ? globalThis.String(object.final_url)
        : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      textContent: isSet(object.textContent)
        ? globalThis.String(object.textContent)
        : isSet(object.text_content)
        ? globalThis.String(object.text_content)
        : "",
      excerpt: isSet(object.excerpt) ? globalThis.String(object.excerpt) : "",
      byline: isSet(object.byline) ? globalThis.String(object.byline) : "",
      siteName: isSet(object.siteName)
        ? globalThis.String(object.siteName)
        : isSet(object.site_name)
        ? globalThis.String(object.site_name)
        : "",
      images: globalThis.Array.isArray(object?.images)
        ? object.images.map((e: any) => Image.fromJSON(e))
        : [],
      readingTime: isSet(object.readingTime)
        ? globalThis.Number(object.readingTime)
        : isSet(object.reading_time)
        ? globalThis.Number(object.reading_time)
        : 0,
      strategy: isSet(object.strategy) ? globalThis.String(object.strategy) : "",
      durationMs: isSet(object.durationMs)
        ? globalThis.Number(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.Number(object.duration_ms)
        : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: FetchResponse): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.finalUrl !== "") {
      obj.finalUrl = message.finalUrl;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.textContent !== "") {
      obj.textContent = message.textContent;
    }
    if (message.excerpt !== "") {
      obj.excerpt = message.excerpt;
    }
    if (message.byline !== "") {
      obj.byline = message.byline;
    }
    if (message.siteName !== "") {
      obj.siteName = message.siteName;
    }
    if (message.images?.length) {
      obj.images = message.images.map((e) => Image.toJSON(e));
    }
    if (message.readingTime !== 0) {
      obj.readingTime = Math.round(message.readingTime);
    }
    if (message.strategy !== "") {
      obj.strategy = message.strategy;
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchResponse>): FetchResponse {
    return FetchResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchResponse>): FetchResponse {
    const message = createBaseFetchResponse();
    message.url = object.url ?? "";
    message.finalUrl = object.finalUrl ?? "";
    message.title = object.title ?? "";
    message.content = object.content ?? "";
    message.textContent = object.textContent ?? "";
    message.excerpt = object.excerpt ?? "";
    message.byline = object.byline ?? "";
    message.siteName = object.siteName ?? "";
    message.images = object.images?.map((e) => Image.fromPartial(e)) || [];
    message.readingTime = object.readingTime ?? 0;
    message.strategy = object.strategy ?? "";
    message.durationMs = object.durationMs ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseImage(): Image {
  return { originalUrl: "", proxyUrl: "", alt: "", isLazy: false };
}

export const Image: MessageFns<Image> = {
  encode(message: Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originalUrl !== "") {
      writer.uint32(10).string(message.originalUrl);
    }
    if (message.proxyUrl !== "") {
      writer.uint32(18).string(message.proxyUrl);
    }
    if (message.alt !== "") {
      writer.uint32(26).string(message.alt);
    }
    if (message.isLazy !== false) {
      writer.uint32(32).bool(message.isLazy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.originalUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proxyUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.alt = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isLazy = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Image {
    return {
      originalUrl: isSet(object.originalUrl)
        ? globalThis.String(object.originalUrl)
        : isSet(object.original_url)
        ? globalThis.String(object.original_url)
        : "",
      proxyUrl: isSet(object.proxyUrl)
        ? globalThis.String(object.proxyUrl)
        : isSet(object.proxy_url)
        ? globalThis.String(object.proxy_url)
        : "",
      alt: isSet(object.alt) ? globalThis.String(object.alt) : "",
      isLazy: isSet(object.isLazy)
        ? globalThis.Boolean(object.isLazy)
        : isSet(object.is_lazy)
        ? globalThis.Boolean(object.is_lazy)
        : false,
    };
  },

  toJSON(message: Image): unknown {
    const obj: any = {};
    if (message.originalUrl !== "") {
      obj.originalUrl = message.originalUrl;
    }
    if (message.proxyUrl !== "") {
      obj.proxyUrl = message.proxyUrl;
    }
    if (message.alt !== "") {
      obj.alt = message.alt;
    }
    if (message.isLazy !== false) {
      obj.isLazy = message.isLazy;
    }
    return obj;
  },

  create(base?: DeepPartial<Image>): Image {
    return Image.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Image>): Image {
    const message = createBaseImage();
    message.originalUrl = object.originalUrl ?? "";
    message.proxyUrl = object.proxyUrl ?? "";
    message.alt = object.alt ?? "";
    message.isLazy = object.isLazy ?? false;
    return message;
  },
};

function createBaseHealthResponse(): HealthResponse {
  return { status: "", maxConcurrent: 0, available: 0, cycletlsEnabled: false };
}

export const HealthResponse: MessageFns<HealthResponse> = {
  encode(message: HealthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.maxConcurrent !== 0) {
      writer.uint32(16).int32(message.maxConcurrent);
    }
    if (message.available !== 0) {
      writer.uint32(24).int32(message.available);
    }
    if (message.cycletlsEnabled !== false) {
      writer.uint32(32).bool(message.cycletlsEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxConcurrent = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.available = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.cycletlsEnabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      maxConcurrent: isSet(object.maxConcurrent)
        ? globalThis.Number(object.maxConcurrent)
        : isSet(object.max_concurrent)
        ? globalThis.Number(object.max_concurrent)
        : 0,
      available: isSet(object.available) ? globalThis.Number(object.available) : 0,
      cycletlsEnabled: isSet(object.cycletlsEnabled)
        ? globalThis.Boolean(object.cycletlsEnabled)
        : isSet(object.cycletls_enabled)
        ? globalThis.Boolean(object.cycletls_enabled)
        : false,
    };
  },

  toJSON(message: HealthResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.maxConcurrent !== 0) {
      obj.maxConcurrent = Math.round(message.maxConcurrent);
    }
    if (message.available !== 0) {
      obj.available = Math.round(message.available);
    }
    if (message.cycletlsEnabled !== false) {
      obj.cycletlsEnabled = message.cycletlsEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<HealthResponse>): HealthResponse {
    return HealthResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthResponse>): HealthResponse {
    const message = createBaseHealthResponse();
    message.status = object.status ?? "";
    message.maxConcurrent = object.maxConcurrent ?? 0;
    message.available = object.available ?? 0;
    message.cycletlsEnabled = object.cycletlsEnabled ?? false;
    return message;
  },
};

function createBaseFetchRawResponse(): FetchRawResponse {
  return { url: "", finalUrl: "", body: "", contentType: "", statusCode: 0, strategy: "", durationMs: 0, error: "" };
}

export const FetchRawResponse: MessageFns<FetchRawResponse> = {
  encode(message: FetchRawResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.finalUrl !== "") {
      writer.uint32(18).string(message.finalUrl);
    }
    if (message.body !== "") {
      writer.uint32(26).string(message.body);
    }
    if (message.contentType !== "") {
      writer.uint32(34).string(message.contentType);
    }
    if (message.statusCode !== 0) {
      writer.uint32(40).int32(message.statusCode);
    }
    if (message.strategy !== "") {
      writer.uint32(50).string(message.strategy);
    }
    if (message.durationMs !== 0) {
      writer.uint32(56).int64(message.durationMs);
    }
    if (message.error !== "") {
      writer.uint32(66).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchRawResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchRawResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.finalUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.statusCode = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.strategy = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.durationMs = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchRawResponse {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      finalUrl: isSet(object.finalUrl)
        ? globalThis.String(object.finalUrl)
        : isSet(object.final_url)
        ? globalThis.String(object.final_url)
        : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      contentType: isSet(object.contentType)
        ? globalThis.String(object.contentType)
        : isSet(object.content_type)
        ? globalThis.String(object.content_type)
        : "",
      statusCode: isSet(object.statusCode)
        ? globalThis.Number(object.statusCode)
        : isSet(object.status_code)
        ? globalThis.Number(object.status_code)
        : 0,
      strategy: isSet(object.strategy) ? globalThis.String(object.strategy) : "",
      durationMs: isSet(object.durationMs)
        ? globalThis.Number(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.Number(object.duration_ms)
        : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: FetchRawResponse): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.finalUrl !== "") {
      obj.finalUrl = message.finalUrl;
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.statusCode !== 0) {
      obj.statusCode = Math.round(message.statusCode);
    }
    if (message.strategy !== "") {
      obj.strategy = message.strategy;
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchRawResponse>): FetchRawResponse {
    return FetchRawResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchRawResponse>): FetchRawResponse {
    const message = createBaseFetchRawResponse();
    message.url = object.url ?? "";
    message.finalUrl = object.finalUrl ?? "";
    message.body = object.body ?? "";
    message.contentType = object.contentType ?? "";
    message.statusCode = object.statusCode ?? 0;
    message.strategy = object.strategy ?? "";
    message.durationMs = object.durationMs ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

/** 抓取服务 */
export type ScraperServiceDefinition = typeof ScraperServiceDefinition;
export const ScraperServiceDefinition = {
  name: "ScraperService",
  fullName: "scraper.ScraperService",
  methods: {
    /** 抓取单个文章 */
    fetchArticle: {
      name: "FetchArticle",
      requestType: FetchRequest,
      requestStream: false,
      responseType: FetchResponse,
      responseStream: false,
      options: {},
    },
    /** 批量抓取 */
    fetchArticles: {
      name: "FetchArticles",
      requestType: FetchRequest,
      requestStream: true,
      responseType: FetchResponse,
      responseStream: true,
      options: {},
    },
    /** 原始抓取（不经过 Readability 处理） */
    fetchRaw: {
      name: "FetchRaw",
      requestType: FetchRequest,
      requestStream: false,
      responseType: FetchRawResponse,
      responseStream: false,
      options: {},
    },
    /** 健康检查 */
    healthCheck: {
      name: "HealthCheck",
      requestType: Empty,
      requestStream: false,
      responseType: HealthResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
